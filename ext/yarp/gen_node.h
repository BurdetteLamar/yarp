/******************************************************************************/
/* This file is generated by the bin/template script and should not be        */
/* modified manually.                                                         */
/******************************************************************************/

#ifndef YARP_NODE_H
#define YARP_NODE_H

#include "location.h"
#include "token.h"
#include <stddef.h>

typedef enum {
  YP_NODE_ASSIGNMENT = 0,
  YP_NODE_BINARY = 1,
  YP_NODE_CHARACTER_LITERAL = 2,
  YP_NODE_CLASS_VARIABLE_READ = 3,
  YP_NODE_CLASS_VARIABLE_WRITE = 4,
  YP_NODE_FALSE_NODE = 5,
  YP_NODE_FLOAT_LITERAL = 6,
  YP_NODE_GLOBAL_VARIABLE_READ = 7,
  YP_NODE_GLOBAL_VARIABLE_WRITE = 8,
  YP_NODE_IDENTIFIER = 9,
  YP_NODE_IF_NODE = 10,
  YP_NODE_IMAGINARY_LITERAL = 11,
  YP_NODE_INSTANCE_VARIABLE_READ = 12,
  YP_NODE_INSTANCE_VARIABLE_WRITE = 13,
  YP_NODE_INTEGER_LITERAL = 14,
  YP_NODE_NIL_NODE = 15,
  YP_NODE_OPERATOR_ASSIGNMENT = 16,
  YP_NODE_PROGRAM = 17,
  YP_NODE_RANGE = 18,
  YP_NODE_RATIONAL_LITERAL = 19,
  YP_NODE_REDO = 20,
  YP_NODE_RETRY = 21,
  YP_NODE_SELF_NODE = 22,
  YP_NODE_STATEMENTS = 23,
  YP_NODE_TERNARY = 24,
  YP_NODE_TRUE_NODE = 25,
  YP_NODE_UNLESS_MODIFIER = 26,
  YP_NODE_UNTIL_MODIFIER = 27,
  YP_NODE_VARIABLE_REFERENCE = 28,
  YP_NODE_WHILE_MODIFIER = 29,
} yp_node_type_t;

struct yp_node;

typedef struct yp_node_list {
  struct yp_node **nodes;
  size_t size;
  size_t capacity;
} yp_node_list_t;

// This is the overall tagged union representing a node in the syntax tree.
typedef struct yp_node {
  // This represents the type of the node. It somewhat maps to the nodes that
  // existed in the original grammar and ripper, but it's not a 1:1 mapping.
  yp_node_type_t type;

  // This is the location of the node in the source. It's a range of bytes
  // containing a start and an end.
  yp_location_t location;

  // Every entry in this union is a different kind of node in the tree. For
  // the most part they only contain one or two child nodes, except for the
  // more complicated nodes like params. There may be an opportunity for
  // optimization here by combining node types that share the same shape, but
  // it might not end up mattering in the final compiled code.
  union {
    // Assignment
    struct {
      struct yp_node *target;
      yp_token_t operator;
      struct yp_node *value;
    } assignment;

    // Binary
    struct {
      struct yp_node *left;
      yp_token_t operator;
      struct yp_node *right;
    } binary;

    // CharacterLiteral
    struct {
      yp_token_t value;
    } character_literal;

    // ClassVariableRead
    struct {
      yp_token_t name;
    } class_variable_read;

    // ClassVariableWrite
    struct {
      yp_token_t name;
      yp_token_t operator;
      struct yp_node *value;
    } class_variable_write;

    // FalseNode
    struct {
      yp_token_t keyword;
    } false_node;

    // FloatLiteral
    struct {
      yp_token_t value;
    } float_literal;

    // GlobalVariableRead
    struct {
      yp_token_t name;
    } global_variable_read;

    // GlobalVariableWrite
    struct {
      yp_token_t name;
      yp_token_t operator;
      struct yp_node *value;
    } global_variable_write;

    // Identifier
    struct {
      yp_token_t value;
    } identifier;

    // IfNode
    struct {
      yp_token_t keyword;
      struct yp_node *predicate;
      struct yp_node *statements;
    } if_node;

    // ImaginaryLiteral
    struct {
      yp_token_t value;
    } imaginary_literal;

    // InstanceVariableRead
    struct {
      yp_token_t name;
    } instance_variable_read;

    // InstanceVariableWrite
    struct {
      yp_token_t name;
      yp_token_t operator;
      struct yp_node *value;
    } instance_variable_write;

    // IntegerLiteral
    struct {
      yp_token_t value;
    } integer_literal;

    // NilNode
    struct {
      yp_token_t keyword;
    } nil_node;

    // OperatorAssignment
    struct {
      struct yp_node *target;
      yp_token_t operator;
      struct yp_node *value;
    } operator_assignment;

    // Program
    struct {
      struct yp_node *statements;
    } program;

    // Range
    struct {
      struct yp_node *left;
      yp_token_t operator;
      struct yp_node *right;
    } range;

    // RationalLiteral
    struct {
      yp_token_t value;
    } rational_literal;

    // Redo
    struct {
      yp_token_t value;
    } redo;

    // Retry
    struct {
      yp_token_t value;
    } retry;

    // SelfNode
    struct {
      yp_token_t keyword;
    } self_node;

    // Statements
    struct {
      struct yp_node_list *body;
    } statements;

    // Ternary
    struct {
      struct yp_node *predicate;
      yp_token_t question_mark;
      struct yp_node *true_expression;
      yp_token_t colon;
      struct yp_node *false_expression;
    } ternary;

    // TrueNode
    struct {
      yp_token_t keyword;
    } true_node;

    // UnlessModifier
    struct {
      struct yp_node *statement;
      yp_token_t keyword;
      struct yp_node *predicate;
    } unless_modifier;

    // UntilModifier
    struct {
      struct yp_node *statement;
      yp_token_t keyword;
      struct yp_node *predicate;
    } until_modifier;

    // VariableReference
    struct {
      yp_token_t value;
    } variable_reference;

    // WhileModifier
    struct {
      struct yp_node *statement;
      yp_token_t keyword;
      struct yp_node *predicate;
    } while_modifier;
  } as;
} yp_node_t;

#endif // YARP_NODE_H
