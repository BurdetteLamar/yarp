package org.yarp;

import java.lang.Override;
import java.lang.String;
import java.lang.StringBuilder;
import java.util.ArrayList;
import java.util.Arrays;

// GENERATED BY <%= File.basename(__FILE__) %>
// @formatter:off
public abstract class Nodes {

    public static final byte[][] EMPTY_BYTE_ARRAY_ARRAY = {};

<%- flags.each do |group| -%>
    public static final class <%= group.name %> implements Comparable<<%= group.name %>> {
        <%- group.values.each_with_index do |value, index| -%>

        // <%= value.comment %>
        public static final int <%= value.name %> = 1 << <%= index %>;
        <%- end -%>

        <%- group.values.each do |value| -%>
        public static boolean is<%= value.camelcase %>(int flags) {
            return (flags & <%= value.name %>) != 0;
        }

        <%- end -%>
        private final int flags;

        public <%= group.name %>(int flags) {
            this.flags = flags;
        }

        @Override
        public int hashCode() {
            return flags;
        }

        @Override
        public boolean equals(Object other) {
            if (!(other instanceof <%= group.name %>)) {
                return false;
            }

            return flags == ((<%= group.name %>) other).flags;
        }

        @Override
        public int compareTo(<%= group.name %> other) {
            return flags - other.flags;
        }

        <%- group.values.each do |value| -%>
        public boolean is<%= value.camelcase %>() {
            return (flags & <%= value.name %>) != 0;
        }

        <%- end -%>
    }

<%- end -%>

    public static final class Location {

        public static final Location[] EMPTY_ARRAY = {};

        public final int startOffset;
        public final int length;

        public Location(int startOffset, int length) {
            this.startOffset = startOffset;
            this.length = length;
        }

        public int length() {
            return length;
        }

        public int endOffset() {
            return startOffset + length;
        }
    }

    public static final class Source {
        public final byte[] bytes;
        private final int[] lineOffsets;

        public Source(byte[] bytes, int[] lineOffsets) {
            assert lineOffsets[0] == 0;
            this.bytes = bytes;
            this.lineOffsets = lineOffsets;
        }

        public int line(int byteOffset) {
            assert byteOffset >= 0 && byteOffset < bytes.length : byteOffset;
            int index = Arrays.binarySearch(lineOffsets, byteOffset);
            int line;
            if (index < 0) {
                line = -index - 1;
            } else {
                line = index + 1;
            }
            assert line >= 1 && line <= getLineCount() : line;
            return line;
        }

        public int getLineCount() {
            return lineOffsets.length;
        }
    }

    public static abstract class Node {

        public static final Node[] EMPTY_ARRAY = {};

        public final int startOffset;
        public final int length;
        private boolean newLineFlag = false;

        public Node(int startOffset, int length) {
            this.startOffset = startOffset;
            this.length = length;
        }

        public int length() {
            return length;
        }

        public int endOffset() {
            return startOffset + length;
        }

        public boolean hasNewLineFlag() {
            return newLineFlag;
        }

        public void setNewLineFlag(Source source, boolean[] newlineMarked) {
            int line = source.line(this.startOffset);
            if (!newlineMarked[line]) {
                newlineMarked[line] = true;
                this.newLineFlag = true;
            }
        }

        public abstract <T> T accept(AbstractNodeVisitor<T> visitor);

        public abstract Node[] childNodes();

        @Override
        public String toString() {
            return toString("");
        }

        private String toString(String indent) {
            StringBuilder builder = new StringBuilder();
            builder.append(indent).append(this.getClass().getSimpleName());
            if (hasNewLineFlag()) {
                builder.append("[Li]");
            }
            builder.append('\n');
            for (Node child : childNodes()) {
                if (child != null) {
                    builder.append(child.toString(indent + "  "));
                }
            }
            return builder.toString();
        }
    }

    <%- nodes.each do |node| -%>

    <%= "#{node.comment.split("\n").map { |line| "// #{line}" }.join("\n    ")}\n" if node.comment -%>
    public static final class <%= node.name -%> extends Node {
        <%- if node.needs_serialized_length? -%>
        public final int serializedLength;
        <%- end -%>
        <%- node.params.each do |param| -%>
        public final <%= param.java_type %> <%= param.name %>;<%= ' // optional' if param.class.name.start_with?('Optional') %>
        <%- end -%>

        <%-
          params = node.needs_serialized_length? ? ["int serializedLength"] : []
          params.concat node.params.map { "#{_1.java_type} #{_1.name}" }
          params.concat ["int startOffset", "int length"]
        -%>
        public <%=node.name -%>(<%= params.join(", ") %>) {
            super(startOffset, length);
        <%- if node.needs_serialized_length? -%>
            this.serializedLength = serializedLength;
        <%- end -%>
        <%- node.params.each do |param| -%>
            this.<%= param.name %> = <%= param.name %>;
        <%- end -%>
        }

        <%- unless node.newline -%>
        public void setNewLineFlag(Source source, boolean[] newlineMarked) {
          <%- node.params.each do |param| -%>
            <%- case param -%>
            <%- when NodeListParam -%>
            for (Nodes.Node node : this.<%= param.name %>) {
                node.setNewLineFlag(source, newlineMarked);
            }
            <%- when NodeParam -%>
            this.<%= param.name %>.setNewLineFlag(source, newlineMarked);
            <%- when OptionalNodeParam -%>
            if (this.<%= param.name %> != null) {
                this.<%= param.name %>.setNewLineFlag(source, newlineMarked);
            }
            <%- when -> _ { !param.java_type.include?("Node") } -%>
            <%- else -%>
            <%- raise "Param type #{param.class} not handled in #{__FILE__ }" -%>
            <%- end -%>
          <%- end -%>
        }
        <%- end -%>

        public Node[] childNodes() {
          <%- if node.params.none?(NodeListParam) and node.params.none?(SingleNodeParam) -%>
            return EMPTY_ARRAY;
          <%- elsif node.params.one?(NodeListParam) and node.params.none?(SingleNodeParam) -%>
            return <%= node.params.grep(NodeListParam).first.name %>;
          <%- elsif node.params.none?(NodeListParam) -%>
            return new Node[] { <%= node.params.grep(SingleNodeParam).map(&:name).join(', ') %> };
          <%- else -%>
            ArrayList<Node> childNodes = new ArrayList<>();
            <%- node.params.each do |param| -%>
              <%- case param -%>
              <%- when SingleNodeParam -%>
            childNodes.add(<%= param.name %>);
              <%- when NodeListParam -%>
            childNodes.addAll(Arrays.asList(<%= param.name %>));
              <%- end -%>
            <%- end -%>
            return childNodes.toArray(EMPTY_ARRAY);
          <%- end -%>
        }

        public <T> T accept(AbstractNodeVisitor<T> visitor) {
            return visitor.visit<%= node.name -%>(this);
        }
    }
    <%- end -%>

}
// @formatter:on
