#!/usr/bin/env ruby

require "erb"
require "yaml"

# This represents a parameter to a node that is itself a node. We pass them as
# references and store them as references.
class NodeParam < Struct.new(:name)
  def decl = "struct yp_node *#{name}"
  def param = "yp_node_t *#{name}"
  def assign = name
  def rbs_class = "Node"
  def child_nodes = name
end

# This represents a parameter to a node that is a list of nodes. We pass them as
# references and store them as references.
class NodeListParam < Struct.new(:name)
  def decl = "struct yp_node_list *#{name}"
  def param = nil
  def assign = "yp_node_list_alloc(parser)"
  def rbs_class = "Array[Node]"
  def child_nodes = "*#{name}"
end

# This represents a parameter to a node that is a token. We pass them as
# references and store them by copying.
class TokenParam < Struct.new(:name)
  def decl = "yp_token_t #{name}"
  def param = "yp_token_t *#{name}"
  def assign = "*#{name}"
  def rbs_class = "Token"
  def child_nodes = nil
end

# This represents using the location of a child node as the location of the
# parent node. It copies the location from the child node directly.
class NodeLocation < Struct.new(:name)
  def to_c
    "#{name}->location"
  end
end

# This represents using a list of nodes as the location of the parent node. When
# we're first creating the node (which is when this is used) we don't have any
# location information, so we'll just initialize it to point to 0.
class NodeListLocation
  def to_c
    "{ .start = 0, .end = 0 }"
  end
end

# This represents using the location of a token as the location of the parent
# node. It calculates the relative byte offsets from the beginning of the file
# to the location of the token.
class TokenLocation < Struct.new(:name)
  def to_c
    "{ .start = #{name}->start - parser->start, .end = #{name}->end - parser->start }"
  end
end

# This represents a location calculated as a range between two different nodes.
# It uses the start byte offset of the first node and the end byte offset of the
# second node.
class Node2NodeLocation < Struct.new(:from, :to)
  def to_c
    "{ .start = #{from}->location.start, .end = #{to}->location.end }"
  end
end

# This class represents a node in the tree, configured by the NODE_TYPES file in
# YAML format. It contains information about the name of the node, the various
# child nodes it contains, and how to obtain the location of the node in the
# source.
class NodeType
  attr_reader :name, :type, :human, :params, :location

  def initialize(config)
    @name = config.fetch("name")

    type = @name.gsub(/(.)([A-Z])/, "\\1_\\2")
    @type = "YP_NODE_#{type.upcase}"
    @human = type.downcase

    @params =
      config.fetch("child_nodes").map do |param|
        type, name = param.split(" ")

        case type
        when "node"
          NodeParam.new(name)
        when "node[]"
          NodeListParam.new(name)
        when "token"
          TokenParam.new(name)
        else
          raise
        end
      end

    @location =
      config.fetch("location").then do |location|
        param_location = ->(name) {
          case found = @params.find { |param| param.name == name }
          when NodeParam
            NodeLocation.new(name)
          when NodeListParam
            NodeListLocation.new
          when TokenParam
            TokenLocation.new(name)
          else
            raise
          end
        }

        if location.include?("->")
          location.split("->").map(&param_location) => [NodeLocation => from, NodeLocation => to]
          Node2NodeLocation.new(from.name, to.name)
        else
          param_location[location]
        end
      end
  end
end

def template(name, types, mark)
  filepath = File.expand_path(name, __dir__)
  contents = File.read(filepath).gsub(mark, ERB.new(File.read(File.expand_path("templates/#{File.basename(name)}.erb", __dir__)), trim_mode: "-").result_with_hash(types: types))
  File.write(filepath, contents)
end

cmark = %r{#{Regexp.escape(<<-CMARKBEGIN)}.+#{Regexp.escape(<<-CMARKEND)}}m
/******************************************************************************/
/* BEGIN TEMPLATE                                                             */
/******************************************************************************/
CMARKBEGIN
/******************************************************************************/
/* END TEMPLATE                                                               */
/******************************************************************************/
CMARKEND

rbmark = %r{#{Regexp.escape(<<-RBMARKBEGIN)}.+#{Regexp.escape(<<-RBMARKEND)}}m
  ##############################################################################
  # BEGIN TEMPLATE                                                             #
  ##############################################################################
RBMARKBEGIN
  ##############################################################################
  # END TEMPLATE                                                               #
  ##############################################################################
RBMARKEND

types = []
YAML.load_file(File.expand_path("../NODE_TYPES", __dir__)).each do |config|
  types << NodeType.new(config)
end

template("../ext/yarp/extension.c", types, cmark)
template("../ext/yarp/yarp.h", types, cmark)
template("../ext/yarp/yarp.c", types, cmark)
template("../lib/yarp.rb", types, rbmark)
