  ##############################################################################
  # BEGIN TEMPLATE                                                             #
  ##############################################################################

  module Serialization
    class << self
      def load(source, serialized)
        require "stringio"

        io = StringIO.new(serialized)
        io.set_encoding(Encoding::BINARY)

        io.read(4) => "YARP"
        io.read(3).unpack("C3") => [0, 1, 0]

        load_node(source, io)
      end

      private

      def load_token(source, io)
        number, start_offset, end_offset = io.read(17).unpack("CQQ")
        type =
          case number
          <%- tokens.each_with_index do |token, index| -%>
          when <%= index %> then :<%= token.name %>
          <%- end -%>
          end

        location = YARP::Location.new(start_offset, end_offset)
        YARP::Token.new(type, source[start_offset...end_offset], location)
      end

      def load_node(source, io)
        type, _length, start_offset, end_offset = io.read(25).unpack("CQQQ")
        location = YARP::Location.new(start_offset, end_offset)

        case type
        <%- nodes.each_with_index do |node, index| -%>
        when <%= index %> then YARP::<%= node.name %>.new(<%= node.params.map { |param|
          case param
          when NodeParam then "load_node(source, io)"
          when OptionalNodeParam then "load_node(source, io)"
          when NodeListParam then "io.read(8).unpack1(\"Q\").times.map { load_node(source, io) }"
          when TokenParam then "load_token(source, io)"
          end
        }.join(", ") -%>, location)
        <%- end -%>
        end
      end
    end
  end

  ##############################################################################
  # END TEMPLATE                                                               #
  ##############################################################################
