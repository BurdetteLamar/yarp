/******************************************************************************/
/* BEGIN TEMPLATE                                                             */
/******************************************************************************/

// Allocate a list of nodes. The parser argument is not used, but is here for
// the future possibility of pre-allocating memory pools.
static yp_node_list_t *
yp_node_list_alloc(yp_parser_t *parser) {
  yp_node_list_t *list = malloc(sizeof(yp_node_list_t));
  list->nodes = NULL;
  list->size = 0;
  list->capacity = 0;
  return list;
}

// Append a new node onto the end of the node list.
void
yp_node_list_append(yp_parser_t *parser, yp_node_list_t *list, yp_node_t *node) {
  if (list->size == list->capacity) {
    list->capacity = list->capacity == 0 ? 4 : list->capacity * 2;
    list->nodes = realloc(list->nodes, list->capacity * sizeof(yp_node_t));
  }
  list->nodes[list->size++] = *node;
}

// Deallocate a list of nodes. The parser argument is not used, but is here for
// the future possibility of pre-allocating memory pools.
static void
yp_node_list_dealloc(yp_parser_t *parser, yp_node_list_t *list) {
  if (list->capacity > 0) {
    for (size_t index = 0; index < list->size; index++) {
      yp_node_dealloc(parser, &list->nodes[index]);
    }
    free(list->nodes);
  }
  free(list);
}

// Allocate the space for a new yp_node_t. Currently we're not using the
// parser argument, but it's there to allow for the future possibility of
// pre-allocating larger memory pools and then pulling from those here.
static inline yp_node_t *
yp_node_alloc(yp_parser_t *parser) {
  return malloc(sizeof(yp_node_t));
}
<%- types.each do |type| -%>

// Allocate a new <%= type.name %> node.
yp_node_t *
<%- params = type.params.map(&:param).compact.join(", ") -%>
yp_node_alloc_<%= type.human %>(yp_parser_t *parser<%= params.empty? ? "" : ", #{params}" %>) {
  yp_node_t *node = yp_node_alloc(parser);
  *node = (yp_node_t) {
    .type = <%= type.type %>,
    .location = <%= type.location.to_c %>,
    .as.<%= type.human %> = {
      <%- type.params.each do |param| -%>
      .<%= param.name %> = <%= param.assign %>,
      <%- end -%>
    }
  };
  return node;
}
<%- end -%>

// Deallocate the space for a yp_node_t. Similarly to yp_node_alloc, we're not
// using the parser argument, but it's there to allow for the future possibility
// of pre-allocating larger memory pools.
void
yp_node_dealloc(yp_parser_t *parser, yp_node_t *node) {
  switch (node->type) {
    <%- types.each do |type| -%>
    case <%= type.type %>:
      <%- type.params.each do |param| -%>
      <%- case param -%>
      <%- when NodeParam -%>
      yp_node_dealloc(parser, node->as.<%= type.human %>.<%= param.name %>);
      <%- when NodeListParam -%>
      yp_node_list_dealloc(parser, node->as.<%= type.human %>.<%= param.name %>);
      <%- end -%>
      <%- end -%>
      free(node);
      break;
    <%- end -%>
  }
}

/******************************************************************************/
/* END TEMPLATE                                                               */
/******************************************************************************/
